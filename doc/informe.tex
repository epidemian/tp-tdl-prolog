% Tamaño de letra.
\documentclass[12pt,titlepage]{article}
%\documentclass{article}

%------------------------------ Paquetes ----------------------------------

% Paquetes:

%Para comentarios multilínea.
\usepackage{verbatim}

% Para tener cabecera y pie de página con un estilo personalizado.
\usepackage{fancyhdr}

% Codificación UTF-8
\usepackage[utf8]{inputenc}

% Tipografía
\usepackage{palatino} % Esta es genial!
\linespread{1.05} % Palatino queda mejor con un poco más de interlineado.
%\usepackage{times} % Times New Roman.


% Castellano.
\usepackage[spanish]{babel}

% Tamaño de página y márgenes.
\usepackage[a4paper, headheight=16pt]{geometry}

% Para \href y \url
\usepackage{hyperref}
\hypersetup{
colorlinks=true,
linkcolor=black,
pdfborder= 0 0 0
}

% Gráficos:

% Para generar pdf.
\usepackage[pdftex]{graphicx}
\usepackage{pdfpages}

% Para captions.
\usepackage{caption}

% Sarpadísima tipografía para listings y \texttt
\usepackage{inconsolata}

\usepackage{xcolor}

% Para ejemplos de código.
\usepackage{listings}
\lstset{ 
    language=Prolog,    
    basicstyle=\ttfamily\small, % Usa inconsolata
    identifierstyle=\ttfamily,
    keywordstyle=\color[rgb]{0,0,1},
    commentstyle=\color[rgb]{0.133,0.545,0.133},
    stringstyle=\color[rgb]{0.627,0.126,0.941},
    morekeywords={true,false},
    showstringspaces=false,     % No muestra underscores en los espacios de los strings.
    backgroundcolor=\color{blue!10}, % Un color suave de fondo (menos chocante que el frame=single)
    breaklines=false,            % Wrappea las lineas automáticamente.
    belowskip=0pt               % Reduce el espacio entre un listing y el párrafo siguiente
    %frame=single               % Un recuadro en los listings.
}

\usepackage{amssymb,amsmath}

% Son necesarios?
%\usepackage{float}

%------------------------------ ~paquetes ---------------------------------

%------------------------- Inicio del documento ---------------------------

\begin{document}

% ---------------------- Encabezado y pie de página -----------------------

% Encabezado: sección a la derecha.
% Pie de página: número de página a la derecha.

\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markboth{}{\thesection\ \ #1}}
\lhead{}
\chead{}
\rhead{\rightmark}
\lfoot{}
\cfoot{}
\rfoot{\thepage}

% ---------------------- ~Encabezado y pie de página ----------------------

% -------------------------- Título y autor(es) ---------------------------

\title{Prolog}
\author{}

% -------------------------- ~Título y autor(es) --------------------------

% ------------------------------- Carátula --------------------------------

\begin{titlepage}

\thispagestyle{empty}

% Logo facultad.
\begin{center}
\includegraphics[scale=0.55]{./fiuba}\\
\textsc{\Large Universidad de Buenos Aires}\\[0.2cm]
\textsc{\Large Facultad de Ingeniería}\\[1.5cm]

% Título central.

\textsc{\large Teoría de Lenguajes (75.31)} \\[0.3cm]
\textsc{\large Trabajo Práctico} \\[0.5cm]

\rule{\linewidth}{0.5mm} \\[0.4cm]
{\huge \bfseries Prolog} \\[0.3cm]
{\Large \bfseries Introducción al lenguaje y a la programación lógica}
\rule{\linewidth}{0.5mm} 

\vfill

% Tabla de integrantes.
\begin{flushleft}
\Large\emph{Integrantes} \\[0.2cm]


% Separación entre columnas.
\begin{tabular}{lll}
Axel Straminsky & XXXXX & axel\_stram@hotmail.com \\
Demian Ferrerio & 88443 & epidemian@gmail.com \\
Martín Paulucci & 88509 & martin.c.paulucci@gmail.com \\
\end{tabular}
\end{flushleft}

% Pie de página de la carátula.
{\Large \today}

\end{center}
\end{titlepage}

% ------------------------------- ~Carátula -------------------------------

% -------------------------------- Índice ---------------------------------

% Hago que las páginas se comiencen a contar a partir de aquí.
\setcounter{page}{1}

% Índice.
\tableofcontents
\newpage

% -------------------------------- ~Índice --------------------------------

% ----------------------------- Inicio del tp -----------------------------

\clearpage	

% Saca la indentación de los párrafos y añade un espacio entre cada uno.
\setlength{\parindent}{0pt}
\setlength{\parskip}{2ex plus 0.5ex minus 0.2ex}

% Luego del índice, links con color.
\hypersetup{
linkcolor=red
}

% Cosas Nuevas -----------------------------------------------------------------

% Nota de traducción: statement = proposición

\section{Programción Lógica}
\subsection{Concepción}

El paradigma de la programación lógica surge de la necesidad de los programadores, o científicos, de expresar formalmente sus objetivos, así como sus conocimientos y suposiciones. La lógica provee las bases para deducir consecuencias a partir de premisas, para encontrar la verdad o la falsedad de una proposición a partir de otras y para verificar la valiz de de un argumento lógico.

Si bien el propósito de las computadoras es ser usadas por personas, la dificultad de su construcción fue tan grande que los lenguajes utilizados para expresar los problemas que estas debían resolver fueron diseñados desde la perspectiva del funcionamiento de la computadora en sí.

Las computadoras modernas están basadas en la arquitectura de von Neumann \cite{vonneumann}, el la cual un programa consiste en una serie de instrucciones que operan sobre registros y que se ejecutan una tras otra, pudiendo la ejecución de una instrucción influir en qué ejecución se ejecute a continuación.

A medida que los programas se hicieron más complejos, se necesitó más esfuerzo para traducir los conceptos que se querían modelar a un lenguaje que las computadoras pudieran interpretar, es decir \emph{programar} se volvió más complejo. Para aliviar este problema se crearon lenguajes con mayor poder de abstracción, capaces de expresar las ideas del progrmador de forma más directa. Partiendo desde el lenguaje ensamblador, y pasando por C, Pascal, Java y muchos otros, todos estos lenguajes son derivados de la arquitectura de von Neumann, y por lo tanto comparten el mismo modelo subyacente de ejecución. Este paradigma de programción es el que se conoce como la \emph{programación imperativa}.

Si bien la lógica se usó como una herramienta para diseñar computadoras y programas desde sus comienzos, su uso directo como lenguaje de progrmación, lo cual se conoce como \emph{programción lógica}, se plantea mucho después \footnote{Finales de la década del 60 o principios de la del 70.} como alternativa a la programción imperativa.

\subsection{Declaratividad}

La programción lógica, así como la programción funcional, perteneca al paradigma de la programción declarativa, y difiere enormemente de la programación imperativa. En vez estar basada en el modelo de von Neumann, la programación declarativa se basa en un modelo abstracto que no guarda ninguna relación con el modelo de la máquina. 

Así, el programador, en vez de tener que adaptar sus ideas a un modelo que se diseñó para una arquitectura de computadora en un momento dado, puede expresarlas sobre un modelo diseñado para ese fín, sin tener que preocuparse por la forma en que luego la computadora ejecutará estas acciones. 

Es decir, un programa en un lenguaje declarativo describe \emph{qué} debe realizarse y no \emph{cómo} debe realizarse.

A modo de ejemplo, se puede mencionar el popular lenguaje de consultas sobre bases de datos SQL. Éste es un lenguaje declarativo ya que el programador SQL expresa las consultas sobre un modelo abstracto (basado en el álgebra relacional) en términos de ``tablas'' y ``registros'', y es luego el entorno de ejecución (llamado motor de base de datos) quien se encarga de traducir estas consultas a instrucciones que la computadora puede ejecutar.

\subsection{Programas Lógicos}
\label{sec:programaslogicos}

Para resolver un problema dentro del paradigma lógico, en vez de darse las instrucciones necesarias para llevar a cabo las operaciones que lo resuelven, se define la información (los conocimientos) del problema y sus suposiciones en forma \emph{axiomas lógicos}. Ese conjunto de aximas es lo que en el paradigma lógico se conoce como \emph{programa}. Para ejecutar el programa se debe proporcionar el problema a resolver, el objetivo, expresado como una \emph{proposición} lógica a ser probada. 

Una ejecución es un intento por encontrar una solución que pruebe el objetivo dado cumpliendo con los axiomas del programa. Esta búsqueda consiste en la aplicación de las reglas de la lógica para inferir conclusiones a partir de los axiomas. El resultado de una ejecución son las soluciones que prueban la proposición objetivo. En caso de no poder probarse el objetivo, quiere decir que el problema no tiene solución dadas las suposiciones explicitadas en el programa. De esta manera, la clave para hacer un programa lógico es poder explicitar el conjunto de axiomas que describa correctamente la solución del problema.

Una característica de la programación lógica es que las proposiciones objetivo son típicamente exitenciales. Es decir, que proponen la existencia de alguna solución que cumple con ciertas propiedades. 

Un ejemplo de una proposición objetivo podría ser ``existe algún $X$ tal que $X$ pertenece a la lista $[4,2,5]$''. El programa donde este objetivo se ejecute deberá tener entonces los axiomas que definan la relación de pertenencia entre un elemento y una lista. Si esos axiomas están bien definidos, el resultado de la ejecución del problema serán las soluciones $X=4$, $X=2$ y $X=5$.

El mismo programa lógico podría usarse para resolver problemas más complejos, por ejemplo ``existe algún $X$ tal que $X$ pertenece a $[3,4,5,6]$ y no pertenece a $[1,2,3,4]$'', cuyas soluciones serían $X=5$ y $X=6$. O ``existen algunos $X$ e $Y$ tales que $X$ pertenece a $[1,2,3]$ e $Y$ pertenece a $[10,20]$'' en cuyo caso las soluciones serían los elementos del producto cartesiano entre los dos conjuntos dados, es decir:
\begin{align*}
X& =1,Y=10& X& =2,Y=10& X& =3,Y=10 \\
X& =1,Y=20& X& =2,Y=20& X& =3,Y=20
\end{align*}

La proposición ``existe algún $X$ tal que $X$ pertenece a $[1, 2]$ y $X$ pertenece a $[3, 4]$'' no podrá ser probada y por lo tanto su solución será vacía.

Las proposiciones objetivo no necesariamente deben ser existenciales. Por ejemplo, la proposición ``$3$ pertenece a $[2,3,4]$'' simplemente será verificada.

Finalmente, las soluciones no necesariamente tienen que ser finitas. Por ejemplo ``existe $L$ tal que $5$ pertenece a $L$'' tiene infinitas soluciones:
\begin{align*}
L& =[5|Y] \\
L& =[X_1, 5|Y] \\
L& =[X_1,X_2,5|Y] \\
 & \cdots
\end{align*}

Donde los $X_i$ representan elementos de cualquier valor en la lista solución, e $Y$ representa una lista de cualquier longitud contenida al final de la lista solución. Es decir que la solución $L=[X_1,5|Y]$,por ejemplo, podría leerse simplemente como ``una lista de al menos dos elementos cuyo segundo elemento es $5$''.

\subsection{Cláusulas de Horn}
\label{sec:horn}

En lógica, una cláusula es una disjunción de literales \cite{clausula}, por ejemplo:
\[
l_1 \lor \cdots \lor l_n
\]

Un cláusula de Horn es un cláusula con a lo sumo un literal positivo \cite{horn_clauses}, por ejemplo:
\[
\lnot b_1 \lor \cdots \lor \lnot b_n \lor h
\]

Lo cual se puede reescribir como una implicación lógica equivalentemente:
\begin{equation} \label{eq:horn}
(b_1 \land \cdots \land b_n) \rightarrow h
\end{equation}

La programación lógica tiene sus bases en las cláusulas de Horn gracias a su interpretación procedural formulada por Robert Kowalski, quien demostró que una clásula de Horn como \eqref{eq:horn} puede resolverse proceduramente \cite{kowalski} planteando $h$ como el encabezado (\emph{head}) de un procedimiento y $b_1 \land \cdots \land b_n$ como su cuerpo (\emph{body}). Lo cual puede leerse proceduralmente como: \emph{para resolver (ejecutar) $h$, resolver (ejecutar) $b_1$ y $b_2$ y $\cdots$ y $b_n$}. 

Para remarcar esta relación entre el encabezado de la cláusula y su cuerpo, en la programción lógica suele utilizarse el operador de consecuencia lógica, cuya notación resulta más similiar a la de una \emph{regla} de Prolog (ver sección \ref{sec:reglas}):
\begin{equation*} 
h \leftarrow (b_1 \land \cdots \land b_n)
\end{equation*}

\newpage
\section{El Lenguaje Prolog}

\subsection{Historia}

El nombre \textit{Prolog} proviene de la abreviatura \textit{PROgrammation en LOGique}. Fue creado por Alain Colmerauer juanto a Philippe Roussel en 1972 en la Universidad de Marsella, y está basado en la interpretación procedual de las Cláusulas de Horn (ver sección \ref{sec:horn}).

La motivación que llevó al nacimiento de Prolog fue hacer un lenguaje que permita hacer programas que llevaran a cabo demostraciones automáticas de teoremas. Así empezaron los primeros trabajos de inteligencia artificial que más de veinte años después dieron lugar al primer lenguaje de programación que contempla, como parte del intérprete, los mecanismos de inferencia necesarios para la demostración automática. Este primer lenguaje está basado en el formalismo matemático de la Lógica de Primer Orden y ha dado inicio a un nuevo y activo campo de investigación entre las matemáticas y la computación que se ha denominado la Programación Lógica.

La Programación Lógica tiene sus orígenes más cercanos en los trabajos de prueba automática de teoremas de los años sesenta. J. A. Robinson propone en 1965 una regla de inferencia a la que llama resolución, mediante la cual la demostración de un teorema puede ser llevada a cabo de manera automática. La resolución es una regla que se aplica sobre cierto tipo de fórmulas del Cálculo de Predicados de Primer Orden, llamadas cláusulas y la demostración de teoremas bajo esta regla de inferencia se lleva a cabo por reducción al absurdo. Como ya se mencionó, Prolog implementa la interpretación de estas cláusulas, lo que, gracias a su eficiencia, relega los intentos anteriores de lenguajes lógicos, y se vuelve el lenguaje lógico más popular.

%\subsection{Usos}

% TODO ???

\subsection{Implementaciones y Extensiones}

Hay, en la actualidad, distintas implementaciónes de Prolog, las cuales, según sus necesidades, implementan distintos \textit{features}.

Algunas de estas implementaciones son:
\begin{itemize}
    \item \textbf{SWI-Prolog} añade multithreading y concurrencia por pasaje de mensajes y aritmética de presición arbitraria entre otras cosas\footnote{\url{http://www.swi-prolog.org/}}.
    \item \textbf{LogTalk} añade orientación a objetos basada tanto en clases como en prototipos\footnote{\url{http://logtalk.org/}}.
    \item \textbf{$\lambda$prolog} soporta programación de alto orden y tipado polimórfico\footnote{\url{http://www.lix.polytechnique.fr/Labo/Dale.Miller/lProlog/}}.
    \item \textbf{Fprolog} añade lógica difusa.
    \item \textbf{Prolog+} añade clases y jerarquías de clases.
\end{itemize}

\subsection{Legado}

Prolog fue el precursor de un paradigma que, si bien hoy en día no goza de una alta popularidad, aún sigue vigente. Influenció la creación de muchos lenguajes lógicos y funcionales, y sigue siendo el lenguaje más utilizado académicamente para enseñar el paradigma lógico.

Algunos de los lenguajes influenciados por Prolog intentaron llevar la lógica más allá del ámbito académico. Datalog\footnote{\url{http://en.wikipedia.org/wiki/Datalog}}, por ejemplo, es un lenguaje de queries para bases de datos deductivas. Mercury\footnote{\url{http://www.mercury.csse.unimelb.edu.au/}}, influenciado tanto por Prolog como por Haskell, es un lenguaje logico/funcional de propósito general.

Probablemente el lenguaje derivado de Prolog de mayor uso en la actualidad sea Erlang\footnote{\url{http://www.erlang.org/}} que, si bien no es un lenguaje lógico, hereda de Prolog la mayoría de su sintaxis y bastante de su semántica (e.g. declaratividad, pattern matching).

Uno de los usos que se le da hoy en día a la programación lógica son los BRMS's (\emph{business rule management system}), que utilizan motores de inferencia de reglas y en general implementan algún lenguaje lógico para la definición de las reglas de negocio. Un ejemplo popular de BRMS es Drools \footnote{\url{http://www.jboss.org/drools/}}

\newpage
\section{Programación en Prolog}

La elementos básicos del lenguaje derivan de la lógica: el término, que unifica todos los tipos de datos; y la proposición (\emph{statement}), que a su vez se divide en tres tipos básicos: hechos, reglas y queries.

La programación Prolog es interactiva: un programa es un conjunto de hechos y reglas, que representan la información de un sistema y las relaciones entre los objetos que lo componen, y para extraer información de éste programa (ejecutarlo), se realizan consultas (queries). 

\subsection{Hechos}

El tipo de proposición más simple en Prolog es el \emph{hecho}. Respresenta una verdad en un programa. Por ejemplo.
\begin{lstlisting}
gato(felix).
\end{lstlisting}
Puede interpretarse como ``Felix es un gato''\footnote{El único único gato.}.

Los hechos sirven para definir relaciones entre elementos. Por ejemplo:
\begin{lstlisting}
padre(zeus, apolo).
\end{lstlisting}
Que puede interpretarse como: la relación \lstinline|padre| se cumple para los elementos \lstinline|zeus| y \lstinline|apolo|. El término utilizado en Prolog para referirse a las relaciones es \emph{predicado} y para los elementos individuales \emph{átomo} (ver Tipos de Datos \ref{sec:datos}). Tanto predicados como átomos deben ser identificadores que comiencen con minúscula.

Los hechos son especialmente útiles para representar relaciones entre un conjunto de elementos finitos, lo cual puede interpretarse como una forma de \emph{base de datos}. Por ejemplo:
\begin{lstlisting}[label=lst:diosesgriegos]
padre(urano, cronos).
padre(cronos, hades).
padre(cronos, poseidon).
padre(cronos, zeus).
padre(zeus, apolo).
padre(zeus, artemisa).
\end{lstlisting}

\subsection{Consultas (Queries)}

Otro tipo de proposición en Prolog son las consultas, o \emph{queries}, que sirven para extraer información de un programa lógico. Las queries se \emph{ejecutan} sobre un programa, es decir, se resuelven a partir de los axiomas definidos en él. En la programción lógica en general se las conoce como \emph{proposición objetivo} (\ref{sec:programaslogicos})

Un ejemplo de query sobre el programa antes visto de los dioses griegos (\ref{lst:diosesgriegos}) podría ser \lstinline|padre(zeus, apolo)|, que, al ejecutarlo\footnote{Los sistemas Prolog en general proveen un ambiente interactivo para ejecutar queries sobre programas. En este trabajo práctico se utilizó la implementación de SWI Prolog.}, el sistema informa que se cumple devolviendo \emph{true}:
%\begin{lstlisting}[basicstyle=\color{green}\ttfamily\small,backgroundcolor=\color{black!70}]
\begin{lstlisting}
?- padre(zeus, apolo).
true.
?- padre(zeus, cronos).
false.
?- padre(juan, tobias).
false.
\end{lstlisting}

Se puede observar que cuando la proposición no se cumple, el resultado es \emph{false}. En este caso, la sintaxis de las queries resulta idéntica a la de los hechos; la diferencia radica en que los hechos se escriben en el programa, mientras que las queries se ejecutan en el el ambiente interactivo de Prolog, el cual antepone \lstinline|?-| en cada linea para diferenciarlas de los resultados.

Este es el tipo más sencillo de queries, es decir, verificar si se cumple un predicado a partir de hechos. Mediante se presenten nuevas construcciones del lenguaje se mostrarán queries más complejas.

\subsection{Variables}

La variable lógica es un término de valor arbitrario (i.e. no especificado). Dar una definición más precisa que esa sería engorroso y probablemente poco claro. Su uso, sin embargo, resulta claro observando algunos ejemplos de queries que utilicen variables.

Volviendo al programa de los dioses griegos (\ref{lst:diosesgriegos}), con el uso de variables, se puede preguntar quién es el padre de Zeus:
\begin{lstlisting}
?- padre(X, zeus).
X = cronos .
\end{lstlisting}

Puede observarse que las variables, a diferencia de los átomos, comienzan con mayúscula.

Las queries con variables son en realidad predicados existenciales. En este caso, la query puede leerse como ``existe $X$ tal que $X$ es padre de Zeus''. 

El resultado de una query, en general, son las substituciones de las variables que ésta utiliza tales que verifiquen la query. Una substitución es un par $\{X=a\}$ donde $X$ es una variable y $a$ es un término.

Puede no existir ninguna substitución de las variables de una query que la verifiquen:
\begin{lstlisting}
?- padre(X, urano).
false.
\end{lstlisting}

No existe valor de \lstinline|X| que verifique \lstinline|padre(X, urano)|, es decir, Urano es huérfano.

Si una query tiene varias soluciones (i.e. varias susbtituciones que la verfican), estas se listan a medida que se resuelven\footnote{En SWI Prolog hay que ingresar \emph{n} (\emph{next}) para que se siga ejecutando la query y se busque la siguiente solución. Si se presiona \emph{enter}, se termina de ejecutar la query.}. Por ejemplo, para listar los hijos de Cronos:
\begin{lstlisting}
?- padre(cronos, X).
X = hades ;
X = poseidon ;
X = zeus.
\end{lstlisting}

Con el uso de variables, pueden escribirse queries más complejas, por ejemplo, si se desea saber si Poseidon y Hades son hermanos:
\begin{lstlisting}
?- padre(X, poseidon), padre(X, hades).
X = cronos .
\end{lstlisting}

Es decir ``existe $X$ tal que $X$ es padre de Poseidon y $X$ es padre de Hades''.

Incluso puede utilizarse más de una variable en una query. Por ejemplo, para conocer todos los hermanos en la base de datos:
\begin{lstlisting}[label=lst:queryhermanos]
% El \== el operador 'distinto'
?- padre(X, A), padre(X, B), A \== B.
X = cronos,
A = hades,
B = poseidon ;
X = cronos,
A = hades,
B = zeus ;
X = cronos,
A = poseidon,
B = hades ;
% ... Hay un total de 8 soluciones.
\end{lstlisting}

Es decir, todas las ternas de individuos $\{X,A,B\}$ tales que $X$ sea padre de $A$ y de $B$, y $A$ y $B$ no sean el mismo individuo. Notar que la entre los resultados aparecen dos veces cada relación de ``hermanos'', por ejemplo $\{X=cronos,A=hades,B=poseidon\}$ y $\{X=cronos,A=poseidon,B=hades\}$ ya que esta relación es ``conmutativa''.

\subsubsection*{Hechos Universales}

Las variables también peuden ser usadas en hechos para definir \emph{hechos universales}. Por ejemplo, si se tiene un predicado \lstinline|gusta/2|\footnote{El \lstinline|/2| define la aridad de un predicado. Ver sección (\ref{sec:datos}).} que indica qué le gusta a cada persona:
\begin{lstlisting}
gusta(lucas, programar).
gusta(juan, dormir).
gusta(juan, tv).
gusta(djfray, cocinar).
% ... etc
\end{lstlisting}

Es un hecho que a todo el mundo le gusta el chocolate (si no lo és, debería). Se podría escribir a mano cada hecho \lstinline|gusta| entre cada individuo y \lstinline|chocolate|, pero eso sería engorroso y además poco robusto, ya que si en un futuro se llegase a consultar por algún individuo no contemplado en esa cantidad finita de hechos daría que a éste no le gusta el chocolate, lo cual es inadmisible. La solución es sencilla, hacer que \lstinline|gusta| sea un hecho para cualquier individuo y \lstinline|chocolate|:
\begin{lstlisting}
gusta(X, chocolate).
\end{lstlisting}

\subsection{Reglas}
\label{sec:reglas}

Los ejemplos interesantes de queries existenciales ya vistos definían en sí relaciones en un modelo. Por ejemplo, la query \lstinline|?- padre(X, A), padre(X, B), A \== B| define la relación ``hermano'' entre \lstinline|A| y \lstinline|B|. Las \emph{reglas}, en principio, pueden utilizarse para plasmar esa relación en el programa lógico mismo y hacer así un modelo más interesante. Esa misma relación de hermandad traducida a una regla sería:
\begin{lstlisting}
hermano(A, B) :- padre(X, A), padre(X, B), A \== B.
\end{lstlisting}

Puede interpretarse como ``$A$ y $B$ son hermanos si existe un $X$ tal que $X$ es padre de $A$ y de $B$ y $A$ y $B$ son distintos''. Así, queda definido un nuevo predicado \lstinline|hermano/2|, que puede ser usado para hacer queries más directas:
\begin{lstlisting}
?- hermano(apolo, artemisa).
true .
\end{lstlisting}

Las reglas son el equivalente en Prolog a las cláusulas de Horn. La forma general de una cláusula de Horn es:
\[
h \leftarrow (b_1 \land \cdots \land b_n)
\]

Que, traducido a una regla de Prolog sería:
\begin{lstlisting}
h :- b1, ..., bn
\end{lstlisting}

Donde $h$ es la cabeza (\emph{head}) de la regla y $(b_1 \land \cdots \land b_n)$ es el cuerpo (\emph{body}), y tanto $h$ como $b_1 \cdots b_n$ son predicados lógicos.

Se puede observar que los hechos son en realidad un caso especial de regla cuando $n=0$. El hecho:
\begin{lstlisting}
gusta(X, chocolate).
\end{lstlisting}

Es equivalente a una regla que se cumple siempre:
\begin{lstlisting}
gusta(X, chocolate) :- true.
\end{lstlisting}

Es importante notar que el cuerpo de una regla es una conjunción lógica (operador \emph{and}). Eso quiere decir, entonces, que la cabeza de una regla es consecia de que se cumplan \emph{todos} los predicados del cuerpo. A veces es deseable plantear que un predicado se cumpla por más de una condición, es decir una disjunción lógica (\emph{or}). Por ejemplo, para modelar la relación ``familiar cercano'' entre dos individuos, $A$ y $B$, que se cumple si ambos son hermanos, o si son padre e hijo, es necesario plantear una disjunción. En Prolog, si bien existen otras formas de hacerlo\footnote{Así como el operador \lstinline|,/2| (la coma) denota una conjunción, el operador \lstinline|;/2| deonta una disjunción, pero no se recomienda su uso, al menos al programador Prolog principiante, ya que puede llevarlo a escribir reglas demasido complejas y no entender bien la idea de que un predicado puede definirse a partir de varias relgas.}, se estila modelar esto usando simplemente múltimples reglas:
\begin{lstlisting}
familiar_cercano(A, B) :- padre(A, B).
familiar_cercano(A, B) :- padre(B, A).
familiar_cercano(A, B) :- hermano(A, B).
\end{lstlisting}

Así, se puede averiguar quiénes son los familiares cercanos de Artemisa:
\begin{lstlisting}
?- familiar_cercano(artemisa, X).
X = zeus ;
X = apolo .
\end{lstlisting}


\subsection{Tipos de Datos}
\label{sec:datos}

Prolog posee un tipo de dato unificado: el \emph{término}. Existen términos simples: los átmos, variables y numerales; y términos compuestos.

\begin{itemize}
    \item Un \textbf{átomo} es simplemente un identificador. No tiene un sentido matemático como los números o las listas. Se escribe como una cadena de caracteres alfanuméricos comenzando con minúscula o entre comillas simples (estos últimos pueden contener espacios y comenzar con mayúscula). Algunos ejemplos de átomos: \lstinline|a|, \lstinline|lunes|, \lstinline|'Teoria de Lenguajes'|.
    \item Los \textbf{numerales} pueden ser tanto enteros como de coma flotante. Los enteros son de especial interés para Prolog, ya que, al ser numerables poseen propiedades que pueden utilizarse para inferencias lógicas, como que existe \emph{siguiente} o el \emph{anterior} de todo número entero.
    \item Una \textbf{variable} representa un valor arbitrario en una expresión, y se escribe como una cadena de caracteres alfanuméricos comenzando por mayúscula, por ejemplo \lstinline|X| o \lstinline|Dia|.
    \item Un \textbf{término compuesto} es una expresión conformada por un átomo, llamado \emph{functor}, y una serie de términos, los \emph{argumentos} separados por coma y rodeados por paréntesis. Ejemplos de términos compuestos pueden ser \lstinline|padre(X, poseidon)| o \lstinline|pertenece(X, [1, 2, 3])|. Las listas y los strings son términos compuestos con una sintaxis especial.
\end{itemize}

\subsection{Recursividad}
\label{sec:recursividad}

Hasta ahora, usando hechos y reglas simples se pudieron definir algunos programas con capacidades de inferencia medianmente interesantes. Pero este tipo de programas no es suficiente para representar un tipo de relaciones muy interesante: las que se definen en base a sí mismas.

A modo de ejemplo, se volverá a utilizar como base el programa de los dioses griegos (\ref{lst:diosesgriegos}). Esta vez se desea representar la relación ``ancestro'' . Una forma ingenua de encarar este problema sería:
\begin{lstlisting}
% ancestro(A, B) verifica si A es ancestro de B.
ancestro(A, B) :- padre(A, B).
ancestro(A, B) :- padre(A, X), padre(X, B).
ancestro(A, B) :- padre(A, X), padre(X, Y), padre(Y, B).
% ... ad-infinitum?
\end{lstlisting}

Es decir, plantear la relación como ``$A$ es ancestro de $B$ si $A$ es padre de $B$, o si $A$ es abuelo de $B$, o si $A$ es bisabuelo de $B$, o si \dots''. Pero, ¿hasta cuándo seguir? ¿Cuántos niveles de ascendencia son suficientes?

Es evidente que planteando la relación ``ancestro'' de esta manera nunca se podría llegar a una forma general. En el intento de generalizar esta relación, surge naturalmente una definición recursiva: ``$A$ es ancestro de $B$ si $A$ es padre de un ancestro de $B$, ó si $A$ es padre de $B$ directamente''.
\begin{lstlisting}
ancestro(A, B) :- padre(A, B).
ancestro(A, B) :- padre(A, X), ancestro(X, B).
\end{lstlisting}

Es importante notar que para definir la regla recursiva es necesario también otra regla no-recursiva que hace las veces de ``condición de corte'' para no caer en la recusividad infinita.

Ahora \lstinline|ancestro/2| funciona bien para cualquier nivel de ascendencia:
\begin{lstlisting}
?- ancestro(urano, apolo).
true .

?- ancestro(X, apolo).
X = zeus ;
X = urano ;
X = cronos .

?- ancestro(X, urano).
false.
\end{lstlisting}

Otra forma de definir \lstinline|ancestro/2|, que resulta funcionalmente equivalente, es:
\begin{lstlisting}
ancestro(A, B) :- padre(A, B).
ancestro(A, B) :- ancestro(A, X), ancestro(X, B).
\end{lstlisting}

Esta forma de definir la relación quizá resulta chocante a primera vista al programador acostrumbrado al paradigma imperativo que ve a las reglas como procedimientos y a los cuerpos de las mismas como llamadas a otros procedimientos. Es importante recordar que \lstinline|ancestro/2| es un predicado definido a partir de dos reglas. Que la segunda regla de \lstinline|ancestro/2| ``llame'' (para ponerlo en términos imperativos, aunque poco correctos) sólo a \lstinline|ancestro/2|, esto no quiere decir que esa llamada sólo vaya a evaluar esa segunda regla para ejecutarse.

Más adelante se verán ejemplos de seguimientos de programas y las definiciones recursivas, en especial el modo en que se resuelven, quedará más claro.

\subsection{Listas}

Las listas en Prolog pueden definirse, como en muchos lenguajes funcionales, de una forma recursiva. 
\[
\textit{lista} = \left\{
  \begin{array}{l}
  \textit{lista vacía} \\
  \textit{un elemento seguido de una lista} \\
  \end{array} \right.
\]

En Prolog, la lista vacía se denota \lstinline|[]|, y una lista conformada por un elemento \lstinline|H| seguido por una lista \lstinline|T| se denota \lstinline$[H|T]$. La elección de nombres \lstinline|H| y \lstinline|T| es en referencia a la convención utilizada generalmente en la programción funcional para referirse al primer elemento de una lista como la \emph{cabeza} (\emph{head}) y al resto como la \emph{cola} (\emph{tail}), y al operador \lstinline$|/2$ como \emph{operador concatenación}. 

Así, la lista con los elementos \lstinline|1|, \lstinline|2| y \lstinline|3| podría escribirse como \lstinline$[1|[2|[3|[]]]]$, pero por suerte existe una notación más conveniente: \lstinline|[1,2,3]|.

\subsubsection*{Pattern Matching}

La notación con el operador concatenación, sin embargo, es útil para hacer \emph{pattern matching} en reglas (o hechos). Por ejemplo:
\begin{lstlisting}
cabeza(H, [H|T]).
\end{lstlisting}

Es una hecho que dice algo trivial: la cabeza de una lista con forma \lstinline$[H|T]$ es \lstinline|H|. Sin embargo, sirve para notar algo importante: la única lista que no \emph{matchea}\footnote{``Igualar'' o ``hacer juego con'' son pésimas traducciones, así que se opta por usar la versión castellanizada.} con \lstinline$[H|T]$ es la lista vacía, hecho que se utiliza a menudo para definir condiciones de corte en predicados recursivos.

En general, cuando una variable sólo se utiliza una vez y luego no se vuelve a hacer referencia a ella (i.e. el valor de la misma no es importante para definir la regla), se suele utilizar un guión bajo como \emph{placeholder} para indicar eso:
\begin{lstlisting}
cabeza(H, [H|_]).
\end{lstlisting}

Algunas queries para empezar a creer en el pattern matching:
\begin{lstlisting}
?- cabeza(X, [4,5,6]).
X = 4.
?- cabeza(X, []).
false.
?- cabeza(3, [1,2,3]).
false.
\end{lstlisting}

Se puede combinar la notación de listas con comas y con operador concatenación para hacer patrones más complejos, por ejemplo:
\begin{lstlisting}
tercer_elemento(X, [_,_,X|_]).
\end{lstlisting}

El patrón \lstinline$[_,_,X|_]$ matchea con cualquier lista de tres elementos o más que tenga \lstinline|X| como tercer elemento.

\subsubsection*{Reglas Recursivas}

Al ser las listas una estructura recursiva en sí mismas, es natural que suelan utilizarse reglas recursivas para definir propiedades sobre ellas. Un ejemplo títpico es el predicado \lstinline|pertenece/2|:
\begin{lstlisting}
% pertenece(X,L) verifica si X es un elemento de la lista L
pertenece(X, [X|_]).
pertenece(X, [_|T]) :- pertenece(X,T).
\end{lstlisting}

La forma de definir un predicado recursivo resulta ya familiar (sección \ref{sec:recursividad}): una hecho básico, ``$X$ pertenece a una lista que comienza con $X$; y una regla recursiva: $X$ pertenece a una lista que comienza con cualquier cosa si pertenece a su cola.

Con ésta definición de \lstinline|pertenece/2| ya se pueden resolver en Prolog todas las consultas que se habían mencionado en la sección Programas Lógicos (\ref{sec:programaslogicos}).

``Existe algún $X$ tal que $X$ pertenece a la lista $[4,2,5]$'':
\begin{lstlisting}
?- pertenece(X, [4,2,5]).
X = 4 ;
X = 2 ;
X = 5.
\end{lstlisting}

``Existe algún $X$ tal que $X$ pertenece a $[3,4,5,6]$ y no pertenece a $[1,2,3,4]$'':
\begin{lstlisting}
?- pertenece(X, [3,4,5,6]), pertenece(X, [1,2,3,4]).
X = 3 ;
X = 4.
\end{lstlisting}

``Existen algunos $X$ e $Y$ tales que $X$ pertenece a $[1,2,3]$ e $Y$ pertenece a $[10,20]$'':
\begin{lstlisting}
?- pertenece(X, [1,2,3]), pertenece(Y, [10,20]).
X = 1,
Y = 10 ;
X = 1,
Y = 20 ;
X = 2,
Y = 10 ;
X = 2,
Y = 20 ;
X = 3,
Y = 10 ;
X = 3,
Y = 20.
\end{lstlisting}

``Existe algún $X$ tal que $X$ pertenece a $[1, 2]$ y $X$ pertenece a $[3, 4]$'':
\begin{lstlisting}
?- pertenece(X, [1,2]), pertenece(X, [3,4]).
false.

\end{lstlisting}

``$3$ pertenece a $[2,3,4]$'':
\begin{lstlisting}
?- pertenece(3, [2,3,4]).
true.
\end{lstlisting}

``Existe $L$ tal que $5$ pertenece a $L$'':
\begin{lstlisting}
?- pertenece(5, L).
L = [5|_G288] ;
L = [_G287, 5|_G291] ;
L = [_G287, _G290, 5|_G294] ;
L = [_G287, _G290, _G293, 5|_G297] ;
L = [_G287, _G290, _G293, _G296, 5|_G300] ;
L = [_G287, _G290, _G293, _G296, _G299, 5|_G303] .
\end{lstlisting}

Este último caso resulta interesante. Las soluciones son infinitas\footnote{Pero por suerte SWI Prolog requiere que el usuario vaya apretando \emph{n} para ir calculando cada solución en vez de intentar calcularlas todas.}, y la forma de cada solución es una lista con un 5. La primer solución es una lista de al menos un elemento, un 5; su cola puede ser una lista arbitraria y eso es lo que representa ese nombre poco-feliz. La segunda solución es una lista de al menos dos elementos, el primero de un valor arbitrario y el segundo un 5. Y así sucesivamente\dots
\newpage
\section{Modelo de ejecución de Prolog}
% Ver página 35 del libro

\subsection{Algoritmo de backtracking}
\subsection{Seguimiento de factorial}
    Algún otro ejemplo? (el de ancestro es copado para hacer un seguimiento =P)

\newpage
\section{Ejemplos complejos}

Vemos a continuación dos ejemplos más completos.

\subsection{Cambio}

``Cambio'' es un programa que simula las posibilidades de cambiar un billete por monedas.

Se tiene un stock de 10 monedas de cada tipo, a saber: 5 centavos, 10 centavos, 25 centavos, 50 centavos, y 1 peso. Es decir, en total se cuenta con 50 monedas. Además, se puede pedir cambio de cualquiera de estos billetes: 2,5,10,20,50, o 100 pesos.

El código fuente del programa es el siguiente:
\lstinputlisting{../src/cambio.pl}

Luego de compilar el programa, vamos a hacer unas pruebas, y a partir de ahí vamos a razonar el funcionamiento del programa:

\subsubsection{Pruebas}

\begin{itemize}
 \item \textbf{Prueba de verificación}: Se pregunta al interprete si se puede cambiar un billete de \$2 por 1 moneda de un peso, 1 de cincuenta, y 2 de veinticinco.

\begin{lstlisting}
?- cambio(2,1,1,2,0,0).
true . 
\end{lstlisting}

Otro ejemplo, podría ser si se puede cambiar un billete de \$2 por 2 monedas de un peso y una de 5 centavos.
\begin{lstlisting}
?- cambio(2,2,0,0,0,1).
false.
\end{lstlisting}

Vemos que una utilidad del programa es verificar una propuesta de cambio es correcta, o no.

 \item \textbf{Prueba con variables}: Ahora, en vez de pasarle valores a la funciones, y que la misma nos conteste si esa condición verifica o no, es decir, si corresponde a un modelo válido o no, vamos a pasarle variables, para que el modelo nos indique \textit{para que valores} se verifica. Hay que tener en cuenta, que al pasar las variables, la solución no es necesariamente única, sino que puede haber una, varias o ninguna solución.

En primer lugar, vamos a pedir cambio de cincuenta, sin restricciones:
\begin{lstlisting}
?- cambio(50,Peso,Cincuenta,Veinticinco,Diez,Cinco).
false.
\end{lstlisting}
Devuelve \textit{false}, eso quiere decir que no encontró ninguna solución posible. Esto es bastante lógico, ya que nos limita el stock de monedas: aún devolviendole todas, no vamos a poder llegar a juntar 50 pesos.

Veamos, ahora un ejemplo que tenga soluciones. Por ejemplo, pidiendo cambio de 5 pesos:
\begin{lstlisting}
?- cambio(5,Peso,Cincuenta,Veinticinco,Diez,Cinco).
Peso = 0,
Cincuenta = 2,
Veinticinco = 10,
Diez = 10,
Cinco = 10 
\end{lstlisting}
Acá vemos una solución posible. Sin embargo, el intérprete nos indica que no es la única. Apretando la tecla ``n'' vemos más soluciones:
\begin{lstlisting}
Peso = 0,
Cincuenta = 3,
Veinticinco = 8,
Diez = 10,
Cinco = 10 ;

Peso = 0,
Cincuenta = 3,
Veinticinco = 9,
Diez = 8,
Cinco = 9 ;

Peso = 0,
Cincuenta = 3,
Veinticinco = 9,
Diez = 9,
Cinco = 7 ;

Peso = 0,
Cincuenta = 3,
Veinticinco = 9,
Diez = 10,
Cinco = 5 
\end{lstlisting}

Y así podríamos seguir un buen rato...

\end{itemize}

\subsubsection{Análisis del Código Fuente}

Veamos el código fuente por partes. En primer lugar, uno se podría preguntar a que se refiere esta parte del código:
\begin{lstlisting}
pertenece(X,[X|_]).
pertenece(X,[_|R]) :- pertenece(X,R).

stock(X) :- pertenece(X,[0,1,2,3,4,5,6,7,8,9,10]).
billetes(X) :- pertenece(X,[2,5,10,20,50,100]).
\end{lstlisting}

Vemos la regla \textit{stock(X)}. Esta regla se puede leer como ``stock(X) es verdadero si X es miembro de la lista formada por números del 1 al 10''. Es decir, si X es un número de 1 a 10, \textit{hay stock de X}. La misma regla se aplica para billetes, solo que en este caso X puede tomar los valores mencionados anteriormente.

La función ``cambio'':

\begin{lstlisting}
cambio(Billete,Peso,Cincuenta,Veinticinco,Diez,Cinco) :-
        stock(Peso),
        stock(Cincuenta),
        stock(Veinticinco),
        stock(Diez),
        stock(Cinco),
        billetes(Billete),
        100*Billete =:= 100*Peso + 50*Cincuenta + 25*Veinticinco + 10*Diez + 5*Cinco.
\end{lstlisting}

Esta función devuelve \textit{true} si se cumplen todas las condiciones enumeradas. Primero, que haya \textit{stock} de monedas, de un peso, cincuenta centavos, veinticinco, 10 , y cinco centavos. Luego, que el billete ingresado tome uno de los valores válidos, a saber, 2,5,10,20,50, o 100. Por último, la condición más importante, que la suma de las monedas sea igual, en valor monetario, al valor del billete.

\subsection{N Reinas}

\newpage
\section{Conclusiones}


\clearpage
\begin{thebibliography}{9}
    \bibitem{artofprolog} Leon Sterling \& Ehud Shapiro, \emph{The Art of Prolog: Advanced Programming Techniques}. The MIT Press, 2nd Edition, 1999.
    \bibitem{vonneumann} \emph{Von Neumann Architecture}, artículo en Wikipedia: \url{http://en.wikipedia.org/wiki/Von\_Neumann\_architecture}
    \bibitem{wiki} \emph{Prolog}, artículo en Wikipedia: \url{http://en.wikipedia.org/wiki/Prolog}
    \bibitem{clausula} \emph{Clause (logic)}, artículo en Wikipedia: \url{http://en.wikipedia.org/wiki/Clause_(logic)}
    \bibitem{horn_clauses} \emph{Horn Clauses}, artículo en Wikipedia: \url{http://en.wikipedia.org/wiki/Horn_clauses}
    \bibitem{kowalski} Robert Kowalski, \emph{Predicate Logic as Programming Language}. IEEE Computer Society Press, 1986.
    \bibitem{hist1} \emph{Historia de Prolog}, \url{http://prolog6.tripod.com/historia.htm}
\end{thebibliography}

% ------------------------------ Fin del tp -------------------------------

\end{document}

%---------------------------- Fin del documento ---------------------------




